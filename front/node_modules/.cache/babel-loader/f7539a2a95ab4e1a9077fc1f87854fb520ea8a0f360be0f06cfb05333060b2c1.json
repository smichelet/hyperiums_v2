{"ast":null,"code":"export function RenderGrid(formattedData, csvFile) {\n  const test = csvFile.split('\\n').slice(1);\n  let maxAbsCoord = 0;\n  test.forEach(row => {\n    const [id, name, govsystem, x, y, race, prod, activity, tag, civlevel] = row.split(',');\n    const absX = Math.abs(parseInt(x));\n    const absY = Math.abs(parseInt(y));\n    const maxAbsCoordRow = Math.max(absX, absY);\n    if (maxAbsCoordRow > maxAbsCoord) {\n      maxAbsCoord = maxAbsCoordRow;\n    }\n  });\n  return maxAbsCoord;\n\n  // const minX = Math.min(...Object.keys(formattedData));\n  // console.log(typeof(minX));\n  // console.log(minX);\n  // const minY = Math.min(...Object.keys(formattedData[minX]))\n  // console.log(typeof(minY));\n  // console.log(minY);\n}\n\n// import React from 'react';\n\n// function RenderGrid({ formattedData }) {\n\n//   if (!formattedData) {\n//     return <div>Loading...</div>;\n//   }\n\n//   const minX = Math.min(...Object.keys(formattedData));\n//   const minY = Math.min(...Object.keys(formattedData[minX]));\n//   const maxX = Math.max(...Object.keys(formattedData));\n//   const maxY = Math.max(...Object.keys(formattedData[maxX]));\n\n//   const cellSize = 40;\n//   const gridStyle = {\n//     display: 'grid',\n//     gridTemplateColumns: `repeat(${maxX - minX + 1}, ${cellSize}px)`,\n//     gridTemplateRows: `repeat(${maxY - minY + 1}, ${cellSize}px)`,\n//     gridGap: '1px',\n//     border: '1px solid black',\n//     margin: '10px',\n//   };\n\n//   return (\n//     <div style={gridStyle}>\n//       {Object.keys(formattedData).map((x) =>\n//         Object.keys(formattedData[x]).map((y) =>\n//         formattedData[x][y].map((planet) => (\n//             <div\n//               key={planet.id}\n//               style={{\n//                 gridColumn: x - minX + 1,\n//                 gridRow: maxY - y + 1,\n//                 backgroundColor: planet.civlevel === 1 ? 'white' : 'gray',\n//                 border: '1px solid black',\n//               }}\n//             >\n//               {planet.name}\n//             </div>\n//           ))\n//         )\n//       )}\n//     </div>\n//   );\n// }\n\n// export default RenderGrid;\n\n// export function RenderGrid(planets) {\n//   const grid = [];\n//   const maxCoord = -31; // maximum des coordonnées x et y\n\n//   // Générer chaque ligne de la grille\n//   for (let y = maxCoord; y >= -maxCoord; y--) {\n//     const row = [];\n\n//     // Générer chaque cellule de la ligne\n//     for (let x = -maxCoord; x <= maxCoord; x++) {\n//     // Vérifier si la cellule contient des planètes\n//     if (planets[x] && planets[x][y]) {\n//       const cell = (\n//         <td key={`${x},${y}`}>\n//           <tr>({x}, {y})</tr>\n//           {planets[x][y].map(planet => (\n//             <div key={planet.name}>\n//               <p>{planet.name} {planet.tag}</p>\n//               {/* Ajoutez ici les autres informations de la planète */}\n//             </div>\n//           ))}\n//         </td>\n//       );\n//       row.push(cell);\n//     } else {\n//       row.push(<td key={`${x},${y}`}></td>);\n//     }}\n\n//     // Ajouter la ligne à la grille\n//     grid.push(<tr key={y}>{row}</tr>);\n//   }\n// \tconsole.log(grid)\n// \treturn grid;\n// }\n_c = RenderGrid;\nvar _c;\n$RefreshReg$(_c, \"RenderGrid\");","map":{"version":3,"names":["RenderGrid","formattedData","csvFile","test","split","slice","maxAbsCoord","forEach","row","id","name","govsystem","x","y","race","prod","activity","tag","civlevel","absX","Math","abs","parseInt","absY","maxAbsCoordRow","max","_c","$RefreshReg$"],"sources":["/home/woot/coding/hyperiums2/front/src/components/renderGrid.js"],"sourcesContent":["export function RenderGrid(formattedData, csvFile) {\n\n  const test = csvFile.split('\\n').slice(1);\n  let maxAbsCoord = 0;\n\n  test.forEach(row => {\n    const [id, name, govsystem, x, y, race, prod, activity, tag, civlevel] = row.split(',');\n\n    const absX = Math.abs(parseInt(x));\n    const absY = Math.abs(parseInt(y));\n    const maxAbsCoordRow = Math.max(absX, absY);\n\n    if (maxAbsCoordRow > maxAbsCoord) {\n      maxAbsCoord = maxAbsCoordRow;\n    }\n  });\n\n  return maxAbsCoord;\n\n  // const minX = Math.min(...Object.keys(formattedData));\n  // console.log(typeof(minX));\n  // console.log(minX);\n  // const minY = Math.min(...Object.keys(formattedData[minX]))\n  // console.log(typeof(minY));\n  // console.log(minY);\n}\n\n\n// import React from 'react';\n\n// function RenderGrid({ formattedData }) {\n\n//   if (!formattedData) {\n//     return <div>Loading...</div>;\n//   }\n\n//   const minX = Math.min(...Object.keys(formattedData));\n//   const minY = Math.min(...Object.keys(formattedData[minX]));\n//   const maxX = Math.max(...Object.keys(formattedData));\n//   const maxY = Math.max(...Object.keys(formattedData[maxX]));\n\n//   const cellSize = 40;\n//   const gridStyle = {\n//     display: 'grid',\n//     gridTemplateColumns: `repeat(${maxX - minX + 1}, ${cellSize}px)`,\n//     gridTemplateRows: `repeat(${maxY - minY + 1}, ${cellSize}px)`,\n//     gridGap: '1px',\n//     border: '1px solid black',\n//     margin: '10px',\n//   };\n\n//   return (\n//     <div style={gridStyle}>\n//       {Object.keys(formattedData).map((x) =>\n//         Object.keys(formattedData[x]).map((y) =>\n//         formattedData[x][y].map((planet) => (\n//             <div\n//               key={planet.id}\n//               style={{\n//                 gridColumn: x - minX + 1,\n//                 gridRow: maxY - y + 1,\n//                 backgroundColor: planet.civlevel === 1 ? 'white' : 'gray',\n//                 border: '1px solid black',\n//               }}\n//             >\n//               {planet.name}\n//             </div>\n//           ))\n//         )\n//       )}\n//     </div>\n//   );\n// }\n\n// export default RenderGrid;\n\n\n\n\n\n\n// export function RenderGrid(planets) {\n//   const grid = [];\n//   const maxCoord = -31; // maximum des coordonnées x et y\n\n//   // Générer chaque ligne de la grille\n//   for (let y = maxCoord; y >= -maxCoord; y--) {\n//     const row = [];\n\n//     // Générer chaque cellule de la ligne\n//     for (let x = -maxCoord; x <= maxCoord; x++) {\n//     // Vérifier si la cellule contient des planètes\n//     if (planets[x] && planets[x][y]) {\n//       const cell = (\n//         <td key={`${x},${y}`}>\n//           <tr>({x}, {y})</tr>\n//           {planets[x][y].map(planet => (\n//             <div key={planet.name}>\n//               <p>{planet.name} {planet.tag}</p>\n//               {/* Ajoutez ici les autres informations de la planète */}\n//             </div>\n//           ))}\n//         </td>\n//       );\n//       row.push(cell);\n//     } else {\n//       row.push(<td key={`${x},${y}`}></td>);\n//     }}\n\n//     // Ajouter la ligne à la grille\n//     grid.push(<tr key={y}>{row}</tr>);\n//   }\n// \tconsole.log(grid)\n// \treturn grid;\n// }"],"mappings":"AAAA,OAAO,SAASA,UAAUA,CAACC,aAAa,EAAEC,OAAO,EAAE;EAEjD,MAAMC,IAAI,GAAGD,OAAO,CAACE,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC;EACzC,IAAIC,WAAW,GAAG,CAAC;EAEnBH,IAAI,CAACI,OAAO,CAACC,GAAG,IAAI;IAClB,MAAM,CAACC,EAAE,EAAEC,IAAI,EAAEC,SAAS,EAAEC,CAAC,EAAEC,CAAC,EAAEC,IAAI,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,QAAQ,CAAC,GAAGV,GAAG,CAACJ,KAAK,CAAC,GAAG,CAAC;IAEvF,MAAMe,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACC,QAAQ,CAACV,CAAC,CAAC,CAAC;IAClC,MAAMW,IAAI,GAAGH,IAAI,CAACC,GAAG,CAACC,QAAQ,CAACT,CAAC,CAAC,CAAC;IAClC,MAAMW,cAAc,GAAGJ,IAAI,CAACK,GAAG,CAACN,IAAI,EAAEI,IAAI,CAAC;IAE3C,IAAIC,cAAc,GAAGlB,WAAW,EAAE;MAChCA,WAAW,GAAGkB,cAAc;IAC9B;EACF,CAAC,CAAC;EAEF,OAAOlB,WAAW;;EAElB;EACA;EACA;EACA;EACA;EACA;AACF;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAAoB,EAAA,GAlHgB1B,UAAU;AAAA,IAAA0B,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}