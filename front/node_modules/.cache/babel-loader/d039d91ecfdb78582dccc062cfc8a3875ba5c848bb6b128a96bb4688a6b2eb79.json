{"ast":null,"code":"import { normalize_columns_array } from './normalize_columns_array.js';\nimport { init_state } from './init_state.js';\nimport { normalize_options } from './normalize_options.js';\nimport { CsvError } from './CsvError.js';\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadÃ©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\nconst transform = function () {\n  let original_options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const {\n        encoding,\n        escape,\n        quote\n      } = this.options;\n      const {\n        quoting,\n        needMoreDataSize,\n        recordDelimiterMaxLength\n      } = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      // If \"record_delimiter\" is yet to be discovered:\n      // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n      // 2. We set the length to windows line ending in the current encoding\n      // Note, that encoding is known from user or bom discovery at that point\n      // recordDelimiterMaxLength,\n      recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n      // Skip if remaining buffer can be an escaped quote\n      quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,\n      // Skip if remaining buffer can be record delimiter following the closing quote\n      quoting ? quote.length + recordDelimiterMaxLength : 0);\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        encoding,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line\n      } = this.options;\n      let {\n        comment,\n        escape,\n        quote,\n        record_delimiter\n      } = this.options;\n      const {\n        bomSkipped,\n        previousBuf,\n        rawBuffer,\n        escapeIsQuote\n      } = this.state;\n      let buf;\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({\n                ...this.original_options,\n                encoding: encoding\n              });\n              // Options will re-evaluate the Buffer with the new encoding\n              ({\n                comment,\n                escape,\n                quote\n              } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                pos += escape.length - 1;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`, bom ? `(${bom} bom)` : undefined], this.options, info, {\n                    field: this.state.field\n                  }));\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n              if (skipCommentLine) {\n                this.info.comment_lines++;\n                // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if (errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if (errRecord !== undefined) return errRecord;\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if (this.state.commenting) {\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            return this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if (errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values\n      } = this.options;\n      const {\n        enabled,\n        record\n      } = this.state;\n      if (enabled === false) {\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err = columns === false ? new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        }) : new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', ['Invalid Record Length:', `columns length is ${columns.length},`,\n        // rename columns\n        `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        });\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n          this.state.error = err;\n          // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n          if (finalErr) return finalErr;\n        }\n      }\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n        return;\n      }\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if (from === 1 || this.info.records >= from) {\n        const {\n          objname\n        } = this.options;\n        // With columns, records are object\n        if (columns !== false) {\n          const obj = {};\n          // Transform record array to an object\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n            const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord], push);\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? obj : [obj[objname], obj], push);\n            if (err) {\n              return err;\n            }\n          }\n          // Without columns, records are array\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n            const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord], push);\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? record : [record[objname], record], push);\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const {\n        firstLineToHeaders\n      } = this.state;\n      try {\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {\n            headers: headers\n          }));\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const {\n        cast,\n        encoding,\n        rtrim,\n        max_record_size\n      } = this.options;\n      const {\n        enabled,\n        wasQuoting\n      } = this.state;\n      // Short circuit for the from_line options\n      if (enabled === false) {\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n        if (err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const {\n        on_record\n      } = this.options;\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const {\n        columns,\n        relax_column_count\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const {\n          timchars\n        } = this.state;\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const {\n        delimiter,\n        ignore_last_delimiters\n      } = this.options;\n      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n        return 0;\n      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n        return 0;\n      }\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const {\n        record_delimiter\n      } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if (rd[0] !== chr) {\n          continue;\n        }\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const {\n        escape\n      } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const {\n        quote\n      } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const {\n        encoding\n      } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n      // Important, the windows line ending must be before mac os 9\n      Buffer.from('\\r\\n', encoding), Buffer.from('\\n', encoding), Buffer.from('\\r', encoding)];\n      loop: for (let i = 0; i < rds.length; i++) {\n        const l = rds[i].length;\n        for (let j = 0; j < l; j++) {\n          if (rds[i][j] !== buf[pos + j]) {\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function (msg) {\n      const {\n        encoding,\n        raw,\n        skip_records_with_error\n      } = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function () {\n      const {\n        columns,\n        raw,\n        encoding\n      } = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function () {\n      const {\n        columns\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        quoting: this.state.wasQuoting\n      };\n    }\n  };\n};\nexport { transform, CsvError };","map":{"version":3,"names":["normalize_columns_array","init_state","normalize_options","CsvError","isRecordEmpty","record","every","field","toString","trim","cr","nl","boms","Buffer","from","transform","original_options","arguments","length","undefined","info","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","options","state","__needMoreData","i","bufLen","end","encoding","escape","quote","quoting","needMoreDataSize","recordDelimiterMaxLength","numOfCharLeft","requiredLength","Math","max","parse","nextBuf","push","close","bom","from_line","ltrim","max_record_size","raw","relax_quotes","rtrim","skip_empty_lines","to","to_line","comment","record_delimiter","bomSkipped","previousBuf","rawBuffer","escapeIsQuote","buf","concat","compare","bomLength","bufBytesStart","slice","pos","wasRowDelimiter","stop","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","escaping","__isEscape","__isQuote","commenting","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","wasQuoting","err","__error","String","fromCharCode","__infoField","prepend","Object","keys","map","b","equals","filter","Boolean","JSON","stringify","column","recordDelimiterLength","skipCommentLine","enabled","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","record_length","lappend","rappend","columns","group_columns_by_name","relax_column_count","relax_column_count_less","relax_column_count_more","skip_records_with_empty_values","recordLength","__firstLineToColumns","expectedRecordLength","error","finalErr","recordHasError","objname","obj","l","disabled","name","Array","isArray","extRecord","assign","__infoRecord","__push","firstLineToHeaders","headers","call","normalizedHeaders","reset","cast","trimRight","f","__cast","on_record","isColumns","castField","__isFloat","parseFloat","cast_date","isTrim","timchars","loop1","timchar","j","value","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","delimiter","ignore_last_delimiters","del","rd","rdLength","rds","loop","msg","skip_records_with_error","Error","on_skip","__infoDataSet","header","index"],"sources":["/home/woot/coding/hyperiums2/front/node_modules/csv-parse/lib/api/index.js"],"sourcesContent":["\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadÃ©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}